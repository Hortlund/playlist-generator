package main

import (
    "html/template"
    "log"
    "net/http"
    // "main/spotify"
    "fmt"
    "strings"
    "io/ioutil"
    "os"
    "encoding/json"
    "net/url"
    "bytes"
    "time"
    "math/rand"

)

var clientID = ""
var clientSecret = ""

var username string
var playlist string
var method string
var songs string
var genres []string

func handler(w http.ResponseWriter, r *http.Request) {
    ts, err := template.ParseFiles("templates/index.html", "templates/head.html", "templates/navbar.html")
    if err != nil {
        log.Println(err.Error())
        http.Error(w, "Internal Server Error", 500)
        return
    }

    // We then use the Execute() method on the template set to write the template
    // content as the response body. The last parameter to Execute() represents any
    // dynamic data that we want to pass in, which for now we'll leave as nil.
    err = ts.Execute(w, nil)
    if err != nil {
        log.Println(err.Error())
        http.Error(w, "Internal Server Error", 500)
    }
}

func callbackHandler(w http.ResponseWriter, r *http.Request) {

    query := r.URL.Query()
    code := query.Get("code")

    // https://accounts.spotify.com/api/token?grant_type=authorization_code&code=$who&redirect_uri=http://localhost:8080/callback&client_id=$client_id&client_secret=$client_secret

    token(w,r,code)

}

func token(w http.ResponseWriter, r *http.Request, code string) {

    client := &http.Client{}

    data := url.Values{}
    data.Set("grant_type", "authorization_code")
    data.Add("code", code)
    data.Add("redirect_uri", "https://dev.cloudbot.se/callback")
    data.Add("client_id", clientID)
    data.Add("client_secret", clientSecret)

    req, err := http.NewRequest("POST","https://accounts.spotify.com/api/token", bytes.NewBufferString(data.Encode()))
    req.Header.Set("Content-Type", "application/x-www-form-urlencoded; param=value") // This makes it work

    if err != nil {
        log.Println(err)
    }
    resp, err := client.Do(req)
    if err != nil {
        log.Println(err)
    }

    defer resp.Body.Close()

    f, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        log.Println(err)
    }
    resp.Body.Close()
    if err != nil {
        log.Fatal(err)
    }
     // fmt.Println(string(f))

     fmt.Fprintf(w,string(f))

    type AutoGenerated struct {
        AccessToken  string `json:"access_token"`
        TokenType    string `json:"token_type"`
        ExpiresIn    int    `json:"expires_in"`
        RefreshToken string `json:"refresh_token"`
        Scope        string `json:"scope"`
    }

    var token AutoGenerated

    // responseData,err := ioutil.ReadAll(resp.Body)
    _ = json.Unmarshal(f, &token)

    // query := r.URL.Query()
    // access_token := query.Get("access_token")
    // fmt.Fprintf(w,access_token)
    createPlaylist(w, r, token.AccessToken)

}

func createPlaylist(w http.ResponseWriter, r *http.Request, access_token string) {

    currentTime := time.Now()
    // m := make(map[string]string)
    // m["name"] = string(currentTime.Format("2006.01.02 15:04:05"))
    // m["description"] = "SPG generated"
    // m["public"] = "false"

    // jsonString, err := json.Marshal(m)

    client := &http.Client{}

    descriptionGenres := strings.Join(genres,", ")
    values := map[string]string{"name": playlist, "description": fmt.Sprintf("SPG generated from cloudbot.se on %s, contains music from %s genre(s)", string(currentTime.Format("2006.01.02 15:04:05")), descriptionGenres), "public": "false"}
    jsonValue, _ := json.Marshal(values)

    // data := url.Values{}
    // data.Set("name", )
    // data.Add("description", "SPG generated")
    // data.Add("public", "false")

    url := fmt.Sprintf("https://api.spotify.com/v1/users/%s/playlists", username)
    auth := fmt.Sprintf("Bearer %s", access_token)
    // fmt.Fprintf(w,auth)
    req, err := http.NewRequest("POST",url, bytes.NewBuffer(jsonValue))
    req.Header.Set("Authorization", auth)
    req.Header.Add("Content-Type", "application/json; param=value") // This makes it work

    if err != nil {
        log.Println(err)
    }
    resp, err := client.Do(req)
    if err != nil {
        log.Println(err)
    }

    defer resp.Body.Close()

    f, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        log.Println(err)
    }
    resp.Body.Close()
    if err != nil {
        log.Fatal(err)
    }
    // fmt.Println(string(f))

    fmt.Fprintf(w,string(f))

    type AutoGenerated struct {
    Collaborative bool   `json:"collaborative"`
    Description   string `json:"description"`
    ExternalUrls  struct {
        Spotify string `json:"spotify"`
    } `json:"external_urls"`
    Followers struct {
        Href  interface{} `json:"href"`
        Total int         `json:"total"`
    } `json:"followers"`
    Href   string        `json:"href"`
    ID     string        `json:"id"`
    Images []interface{} `json:"images"`
    Name   string        `json:"name"`
    Owner  struct {
        DisplayName  string `json:"display_name"`
        ExternalUrls struct {
            Spotify string `json:"spotify"`
        } `json:"external_urls"`
        Href string `json:"href"`
        ID   string `json:"id"`
        Type string `json:"type"`
        URI  string `json:"uri"`
    } `json:"owner"`
    PrimaryColor interface{} `json:"primary_color"`
    Public       bool        `json:"public"`
    SnapshotID   string      `json:"snapshot_id"`
    Tracks       struct {
        Href     string        `json:"href"`
        Items    []interface{} `json:"items"`
        Limit    int           `json:"limit"`
        Next     interface{}   `json:"next"`
        Offset   int           `json:"offset"`
        Previous interface{}   `json:"previous"`
        Total    int           `json:"total"`
    } `json:"tracks"`
    Type string `json:"type"`
    URI  string `json:"uri"`
}

var playlist AutoGenerated

_ = json.Unmarshal(f, &playlist)

addSongsToPlaylist(w, r, access_token, playlist.ID, playlist.ExternalUrls.Spotify)

}

func addSongsToPlaylist(w http.ResponseWriter, r *http.Request, access_token string, playlistID string, playlistURL string) {

    // ts, err := template.ParseFiles("templates/spotify-thanks.html", "templates/head.html", "templates/navbar.html")

    gepp := strings.Join(genres,",")
    songs := apicall(songs, gepp, access_token, w, r)
    
    // currentTime := time.Now()
    // m := make(map[string]string)
    // m["name"] = string(currentTime.Format("2006.01.02 15:04:05"))
    // m["description"] = "SPG generated"
    // m["public"] = "false"

    // jsonString, err := json.Marshal(m)

    client := &http.Client{}

    values := map[string][]string{"uris": songs}

    jsonValue, _ := json.Marshal(values)

    // fmt.Fprintf(w,string(jsonValue))

    // data := url.Values{}
    // data.Set("name", )
    // data.Add("description", "SPG generated")
    // data.Add("public", "false")

    url := fmt.Sprintf("https://api.spotify.com/v1/playlists/%s/tracks", playlistID)
    auth := fmt.Sprintf("Bearer %s", access_token)
    // fmt.Fprintf(w,auth)
    req, err := http.NewRequest("POST",url, bytes.NewBuffer(jsonValue))
    req.Header.Set("Authorization", auth)
    req.Header.Add("Content-Type", "application/json; param=value") // This makes it work

    resp, err := client.Do(req)
    if err != nil {
        log.Println(err)
    }

    defer resp.Body.Close()

    f, err := ioutil.ReadAll(resp.Body)
    // if err != nil {
    //     log.Println(err)
    // }
    // resp.Body.Close()
    // if err != nil {
    //     log.Fatal(err)
    // }
    // fmt.Println(string(f))

    fmt.Fprintf(w,string(f))

    // type Variables struct { 
    //     link    string  
    //     nm       string
    // }

    // var PageVars Variables
    // PageVars = Variables{
    //     link: playlistURL,
    //     nm: playlist,
    // }

    // err = ts.Execute(w, struct {
    //     Link string
    //     Name string
    // }{playlistURL, playlist})
    // if err != nil {
    //     log.Println(err.Error())
    //     http.Error(w, "Internal Server Error", 500)
    //     // spotify.Apicall()
    // }

}

func spotifyHandler(w http.ResponseWriter, r *http.Request) {
    x := [...]string{"acoustic","afrobeat","alt-rock","alternative","ambient","anime","black-metal","bluegrass","blues","bossanova","brazil","breakbeat","british","cantopop","chicago-house","children","chill","classical","club","comedy","country","dance","dancehall","death-metal","deep-house","detroit-techno","disco","disney","drum-and-bass","dub","dubstep","edm","electro","electronic","emo","folk","forro","french","funk","garage","german","gospel","goth","grindcore","groove","grunge","guitar","happy","hard-rock","hardcore","hardstyle","heavy-metal","hip-hop","holidays","honky-tonk","house","idm","indian","indie","indie-pop","industrial","iranian","j-dance","j-idol","j-pop","j-rock","jazz","k-pop","kids","latin","latino","malay","mandopop","metal","metal-misc","metalcore","minimal-techno","movies","mpb","new-age","new-release","opera","pagode","party","philippines-opm","piano","pop","pop-film","post-dubstep","power-pop","progressive-house","psych-rock","punk","punk-rock","r-n-b","rainy-day","reggae","reggaeton","road-trip","rock","rock-n-roll","rockabilly","romance","sad","salsa","samba","sertanejo","show-tunes","singer-songwriter","ska","sleep","songwriter","soul","soundtracks","spanish","study","summer","swedish","synth-pop","tango","techno","trance","trip-hop","turkish","work-out","world-music"}
    ts, err := template.ParseFiles("templates/spotify.html", "templates/spotify-thanks.html", "templates/head.html", "templates/navbar.html")
    
    if err != nil {
    log.Println(err.Error())
    http.Error(w, "Internal Server Error", 500)
    return
    }

    switch r.Method {

    // https://dev.cloudbot.se/callback?error=access_denied&state=34fFs29kd09
    case "GET":
            err = ts.Execute(w, x)
            if err != nil {
                log.Println(err.Error())
                http.Error(w, "Internal Server Error", 500)
                // spotify.Apicall()
            }
    case "POST":
         


        // kek := auth();
        // Call ParseForm() to parse the raw query and update r.PostForm and r.Form.
        if err := r.ParseForm(); err != nil {
            fmt.Fprintf(w, "ParseForm() err: %v", err)
            return
        }
        // fmt.Fprintf(w, "Post from website! r.PostFrom = %v\n", r.PostForm)
        username = r.FormValue("username")
        playlist = r.FormValue("playlist")
        method = r.FormValue("method")
        songs = r.FormValue("songs")
        genres = r.Form["genres"]

        rand.Seed(time.Now().Unix())
        if len(genres) == 0 {
            for i := range x {
                j := rand.Intn(i + 1)
                x[i], x[j] = x[j], x[i]
            }

            numberOfGenres := rand.Intn(4 - 1) + 1
              for i := 0; i < numberOfGenres; i++ {
                genres = append(genres, x[i])
              }
            // fmt.Fprintf(w, "Username = %v\n", genres)

        }

        // fmt.Fprintf(w, "Username = %s\n", username)
        // fmt.Fprintf(w, "Playlist = %s\n", playlist)
        // fmt.Fprintf(w, "Method = %s\n", method)
        // fmt.Fprintf(w, "Songs = %s\n", songs)
        // fmt.Fprintf(w, "Genres = %v\n", genres)

        // gepp := strings.Join(genres,",")

        
        // fmt.Fprintf(w,gepp)
        // q := req.URL.Query()
        // q.Add("limit", songs)
        // q.Add("market", "SE")
        // q.Add("seed_genres", gepp)
        // req.URL.RawQuery = q.Encode()

        // fmt.Fprintf(w,req.URL.String())
        // response, err := http.Get(fmt.Sprintf("https://api.spotify.com/v1/recommendations?limit=%s&market=SE&seed_genres=%v", songs, genres))

        // m := apicall(songs, gepp)
       
        // fmt.Println(m)
        // for k, v := range m {
        //     fmt.Fprintf(w,"%s value is %v\n", k, v)
        //     // fmt.Fprintf(w,k,v,"\n")
        // }
        // fmt.Fprintf(w,kek)

        http.Redirect(w, r, "https://accounts.spotify.com/authorize?client_id=85c2980f53ce4cc5963f9892208d0ec5&redirect_uri=https://dev.cloudbot.se/callback&response_type=code&scope=playlist-modify-public+playlist-modify-private&state=34fFs29kd09", 301)
    }

    
}

func apicall(songs string, gepp string, access_token string, w http.ResponseWriter, r *http.Request) []string {

    // kek := auth();

    client := &http.Client{}
    req, err := http.NewRequest("GET", "https://api.spotify.com/v1/recommendations", nil)
    if err != nil {
        log.Print(err)
        os.Exit(1)
    }

    type AutoGenerated struct {
    Tracks []struct {
        Album struct {
            AlbumType string `json:"album_type"`
            Artists   []struct {
                ExternalUrls struct {
                    Spotify string `json:"spotify"`
                } `json:"external_urls"`
                Href string `json:"href"`
                ID   string `json:"id"`
                Name string `json:"name"`
                Type string `json:"type"`
                URI  string `json:"uri"`
            } `json:"artists"`
            ExternalUrls struct {
                Spotify string `json:"spotify"`
            } `json:"external_urls"`
            Href   string `json:"href"`
            ID     string `json:"id"`
            Images []struct {
                Height int    `json:"height"`
                URL    string `json:"url"`
                Width  int    `json:"width"`
            } `json:"images"`
            Name                 string `json:"name"`
            ReleaseDate          string `json:"release_date"`
            ReleaseDatePrecision string `json:"release_date_precision"`
            TotalTracks          int    `json:"total_tracks"`
            Type                 string `json:"type"`
            URI                  string `json:"uri"`
        } `json:"album"`
        Artists []struct {
            ExternalUrls struct {
                Spotify string `json:"spotify"`
            } `json:"external_urls"`
            Href string `json:"href"`
            ID   string `json:"id"`
            Name string `json:"name"`
            Type string `json:"type"`
            URI  string `json:"uri"`
        } `json:"artists"`
        DiscNumber  int  `json:"disc_number"`
        DurationMs  int  `json:"duration_ms"`
        Explicit    bool `json:"explicit"`
        ExternalIds struct {
            Isrc string `json:"isrc"`
        } `json:"external_ids"`
        ExternalUrls struct {
            Spotify string `json:"spotify"`
        } `json:"external_urls"`
        Href        string `json:"href"`
        ID          string `json:"id"`
        IsLocal     bool   `json:"is_local"`
        IsPlayable  bool   `json:"is_playable"`
        Name        string `json:"name"`
        Popularity  int    `json:"popularity"`
        PreviewURL  string `json:"preview_url"`
        TrackNumber int    `json:"track_number"`
        Type        string `json:"type"`
        URI         string `json:"uri"`
        LinkedFrom  struct {
            ExternalUrls struct {
                Spotify string `json:"spotify"`
            } `json:"external_urls"`
            Href string `json:"href"`
            ID   string `json:"id"`
            Type string `json:"type"`
            URI  string `json:"uri"`
        } `json:"linked_from,omitempty"`
    } `json:"tracks"`
    Seeds []struct {
        InitialPoolSize    int         `json:"initialPoolSize"`
        AfterFilteringSize int         `json:"afterFilteringSize"`
        AfterRelinkingSize int         `json:"afterRelinkingSize"`
        ID                 string      `json:"id"`
        Type               string      `json:"type"`
        Href               interface{} `json:"href"`
    } `json:"seeds"`
}

    var song AutoGenerated

    auth := fmt.Sprintf("Bearer %s", access_token)
    req.Header.Set("Authorization", auth)
    q := req.URL.Query()
    q.Add("limit", songs)
    q.Add("market", "SE")
    q.Add("seed_genres", gepp)
    req.URL.RawQuery = q.Encode()
    response, err := client.Do(req)
    if err != nil {
        log.Fatal(err)
    }
    defer response.Body.Close()
    responseData,err := ioutil.ReadAll(response.Body)
    _ = json.Unmarshal(responseData, &song)

    m := make(map[string]string)
    songURIS := []string{}
    for i := range song.Tracks {
        m[song.Tracks[i].Name] = song.Tracks[i].URI
        songURIS = append(songURIS, song.Tracks[i].URI)
    }

    // URIstring := strings.Join(songURIS[:], ",")
    // fmt.Fprintf(w,string(URIstring))
    return songURIS
}

//Use to better handle code structure in the future 
// func testHandler(w http.ResponseWriter, r *http.Request) {

//     spotify.Apicall(w, r)

// }

func main() {
    http.HandleFunc("/", handler)
    http.HandleFunc("/spotify", spotifyHandler)
    http.HandleFunc("/callback", callbackHandler)
    // http.HandleFunc("/test", testHandler)
    log.Fatal(http.ListenAndServe(":8080", nil))
}
